http://glenkramer.com/ucdavis/code/trf_gen2.html


Generator of Self-Similar Network Traffic (version 2)

This file contains description of a trace generating utility. Refer to description of version 1 for more information
Distribution list

    _types.h
    _link.h
    _util.h
    _rand_MT.h
    trace.h
    source.h
    aggreg.h
    MersenneTwister.h

What is new

    Mersenne Twister random number generator designed by Makoto Matsumoto and Takuji Nishimura was used instead of built-in rand() function. We used Mersenne Twister RNG implemented as C++ class by Rick Wagner. Generating random values using MTrand class is much faster than using rand() built-in function. Additionally, it generates 32bit random values, while rand() return 16 bit numbers. That greatly reduced effects of tail truncation in a generated Pareto series.
    Source constructor is modified to accept the following parameters



        SourcePareto(   int16u id,          // 16-bit source id
                        int16u prior,       // priority assignemnt for all the packets generated by that source
                        pct_size_t pct_sz,  // packet size 
                        pct_size_t ipgap,   // inter-packet gap (including the preamble)
                        DOUBLE load,        // load offered by the source
                        DOUBLE on_shape,    // shape parameter for the distribution of sizes of ON periods
                        DOUBLE off_shape    // shape parameter for the distribution of sizes of OFF periods
                    )

    The minimum OFF period (location parameter for the OFF periods) was removed from the argument list because it is a secondary parameter dependent on load. Given a desired load, the minimum gap is calculated by the SourcePareto constructor automatically.

The following are public methods of class Generator



    Generator(void);                    // Class constructor does not accept any arguments

    void    Reset( void );              // resets all statistic variables and elapsed time
                                        // Reset should be called to generate multiple traces 
                                        // with same set of sources 

    void    AddSource( Source* );       // add a new source to the generator

    void    RemoveSource( Source* p );  // removes source pointed to by p
    Source* RemoveSource( void );       // removes first source from the (internal)list

    void    SetLoad( DOUBLE newload );  // sets total node load (all N sources are to have 
                                        // equal load of newload/N)	
  
    Trace   PeekNextPacket(void);       // peeks at next packet before it arrives
    Trace   GetNextPacket(void);        // returns the next packet from the aggregated traffic

The following is a simple function that creates an instance of generator and generates (prints out) 1 mln. traces obtained by aggregating 128 sources of ON/OFF periods with cumulative load of 30%.



void main( void )
{

    int    sources = 128;
    double load    = 0.3;
    long   traces  = 1000000;

    Generator AG;

    // add sources
    for( int src = 0; src < sources; src++ )
        AG.AddSource( new SourcePareto( src, 0, packet_size(), 9, load / sources, 1.4, 1.2 ));
    
    // output traces
    while( traces-- > 0 )
	cout << AG.GetNextPacket();

    // delete sources
    for( Source* psrc = AG.RemoveSource(); psrc; psrc = AG.RemoveSource())
	delete psrc;
    
}

To verify the correctness of the traffic generator we plotted a Variance-Time log-log plot. We used shape parameter for the ON periods α = 1.4. The choice of α was prompted by measurements on actual Ethernet traffic performed by Leland et al. [1]. They reported the measured Hurst parameter of 0.8 for moderate network load. The relationship between the Hurst parameter and the shape parameter α is H = (3 - α)/2 (see [2]). Thus, α = 1.4 should result in H = 0.8.

Figure insert.

Figure above shows a variance-time log-log plot. We ran the generator with n = 32, 128, 512, and 2048 sources. The plot shows linear dependency with slope s = �0.4. The slope is related to Hurst parameter as s = 2H � 2. That results in H = 1 + s/2 = 0.8, as expected.

Reader is referred to [3] for an introduction to the concepts of self-similarity and long-range dependence.

[1] 	W. Leland, M. Taqqu, W. Willinger, and D. Wilson, �On the Self-Similar Nature of Ethernet Traffic (Extended Version),� IEEE/ACM Transactions on Networking, 2(1), pp. 1-15, February 1994.
[2] 	W. Willinger, M. Taqqu, R. Sherman, and D. Wilson. �Self-similarity through high-variability: statistical analysis of Ethernet LAN traffic at the source level,� In Proc. ACM SIGCOMM '95, pp. 100-113, 1995.
[3] 	K. Park and W. Willinger, Self-similar network traffic: An overview, In K. Park and W. Willinger, editors, Self-Similar Network Traffic and Performance Evaluation. Wiley Interscience, 2000.


